<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: MyUnorderedMap&lt; Key, T, Hash, Cmp, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMyUnorderedMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MyUnorderedMap&lt; Key, T, Hash, Cmp, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>MyUnordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. Keys with the same hash code appear in the same bucket. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.  
 <a href="classMyUnorderedMap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="my__unordered__map_8hpp_source.html">my_unordered_map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">Any_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e66b809656366669087916c9ebc18e2"><td class="memItemLeft" align="right" valign="top"><a id="a2e66b809656366669087916c9ebc18e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">Any_iterator</a>&lt; true &gt;</td></tr>
<tr class="separator:a2e66b809656366669087916c9ebc18e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78fb5e946caf7d33ac4fc7f5bcbcc9b"><td class="memItemLeft" align="right" valign="top"><a id="ac78fb5e946caf7d33ac4fc7f5bcbcc9b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">Any_iterator</a>&lt; false &gt;</td></tr>
<tr class="separator:ac78fb5e946caf7d33ac4fc7f5bcbcc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e5b6efbf4443bb026a163678aa9c6c6"><td class="memItemLeft" align="right" valign="top"><a id="a2e5b6efbf4443bb026a163678aa9c6c6"></a>
<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a2e5b6efbf4443bb026a163678aa9c6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0841186572c9797caec76627445db4"><td class="memItemLeft" align="right" valign="top"><a id="afe0841186572c9797caec76627445db4"></a>
<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:afe0841186572c9797caec76627445db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678306307c3a9e43484fb9e2bab1a54d"><td class="memItemLeft" align="right" valign="top"><a id="a678306307c3a9e43484fb9e2bab1a54d"></a>
<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:a678306307c3a9e43484fb9e2bab1a54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaee186670a3f2727f828650cfa7ff6"><td class="memItemLeft" align="right" valign="top"><a id="a1aaee186670a3f2727f828650cfa7ff6"></a>
<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:a1aaee186670a3f2727f828650cfa7ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ec15b70edeaee7de82916aa4c807e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#ab7ec15b70edeaee7de82916aa4c807e5">max_load_factor</a> (float f) noexcept</td></tr>
<tr class="memdesc:ab7ec15b70edeaee7de82916aa4c807e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">manages maximum average number of elements per bucket Sets the maximum load factor to ml.  <a href="classMyUnorderedMap.html#ab7ec15b70edeaee7de82916aa4c807e5">More...</a><br /></td></tr>
<tr class="separator:ab7ec15b70edeaee7de82916aa4c807e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9044c1d76eb81eea837dd2adb5639d31"><td class="memItemLeft" align="right" valign="top"><a id="a9044c1d76eb81eea837dd2adb5639d31"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a9044c1d76eb81eea837dd2adb5639d31">max_load_factor</a> () const noexcept</td></tr>
<tr class="memdesc:a9044c1d76eb81eea837dd2adb5639d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">manages maximum average number of elements per bucket Returns current maximum load factor <br /></td></tr>
<tr class="separator:a9044c1d76eb81eea837dd2adb5639d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118dacf40cf01226669ac54e8e2f98a6"><td class="memItemLeft" align="right" valign="top"><a id="a118dacf40cf01226669ac54e8e2f98a6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6">size</a> () const noexcept</td></tr>
<tr class="memdesc:a118dacf40cf01226669ac54e8e2f98a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of buckets <br /></td></tr>
<tr class="separator:a118dacf40cf01226669ac54e8e2f98a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632aa855c40b4c4c2ebaaffdae177b4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a632aa855c40b4c4c2ebaaffdae177b4f">count</a> () const noexcept</td></tr>
<tr class="memdesc:a632aa855c40b4c4c2ebaaffdae177b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling  <a href="classMyUnorderedMap.html#a632aa855c40b4c4c2ebaaffdae177b4f">More...</a><br /></td></tr>
<tr class="separator:a632aa855c40b4c4c2ebaaffdae177b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae737a9f673fee1db8f08726be2c0aef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#ae737a9f673fee1db8f08726be2c0aef2">empty</a> () const noexcept</td></tr>
<tr class="memdesc:ae737a9f673fee1db8f08726be2c0aef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether the container is empty  <a href="classMyUnorderedMap.html#ae737a9f673fee1db8f08726be2c0aef2">More...</a><br /></td></tr>
<tr class="separator:ae737a9f673fee1db8f08726be2c0aef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8d2988d453147bd081d51a947dc45f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#afa8d2988d453147bd081d51a947dc45f">load_factor</a> () const noexcept</td></tr>
<tr class="memdesc:afa8d2988d453147bd081d51a947dc45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns average number of elements per bucket  <a href="classMyUnorderedMap.html#afa8d2988d453147bd081d51a947dc45f">More...</a><br /></td></tr>
<tr class="separator:afa8d2988d453147bd081d51a947dc45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa805ead18c7abac53e5ede823d104411"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#aa805ead18c7abac53e5ede823d104411">MyUnorderedMap</a> ()</td></tr>
<tr class="memdesc:aa805ead18c7abac53e5ede823d104411"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor.constructs the unordered_map  <a href="classMyUnorderedMap.html#aa805ead18c7abac53e5ede823d104411">More...</a><br /></td></tr>
<tr class="separator:aa805ead18c7abac53e5ede823d104411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfad28fffbcb9b202ba6d5aa04fc4af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#afdfad28fffbcb9b202ba6d5aa04fc4af">MyUnorderedMap</a> (const <a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;map)</td></tr>
<tr class="memdesc:afdfad28fffbcb9b202ba6d5aa04fc4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling  <a href="classMyUnorderedMap.html#afdfad28fffbcb9b202ba6d5aa04fc4af">More...</a><br /></td></tr>
<tr class="separator:afdfad28fffbcb9b202ba6d5aa04fc4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440352d113f9723a12de9623ea0f62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a2440352d113f9723a12de9623ea0f62f">operator=</a> (const <a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;map)</td></tr>
<tr class="memdesc:a2440352d113f9723a12de9623ea0f62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. Replaces the contents with a copy of the contents of other.  <a href="classMyUnorderedMap.html#a2440352d113f9723a12de9623ea0f62f">More...</a><br /></td></tr>
<tr class="separator:a2440352d113f9723a12de9623ea0f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ecf84abb917233edc582a05a199b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#ac59ecf84abb917233edc582a05a199b7">MyUnorderedMap</a> (<a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&amp;map) noexcept</td></tr>
<tr class="memdesc:ac59ecf84abb917233edc582a05a199b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other.  <a href="classMyUnorderedMap.html#ac59ecf84abb917233edc582a05a199b7">More...</a><br /></td></tr>
<tr class="separator:ac59ecf84abb917233edc582a05a199b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd839d74e8244732cc55673208923fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#afcd839d74e8244732cc55673208923fd">operator=</a> (<a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&amp;map) noexcept</td></tr>
<tr class="memdesc:afcd839d74e8244732cc55673208923fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.  <a href="classMyUnorderedMap.html#afcd839d74e8244732cc55673208923fd">More...</a><br /></td></tr>
<tr class="separator:afcd839d74e8244732cc55673208923fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5642e4af506856109ed7c60b9c8983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a4c5642e4af506856109ed7c60b9c8983">rehash</a> (size_t new_size)</td></tr>
<tr class="memdesc:a4c5642e4af506856109ed7c60b9c8983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count &lt; <a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6" title="returns the number of buckets">size()</a> / <a class="el" href="classMyUnorderedMap.html#ab7ec15b70edeaee7de82916aa4c807e5" title="manages maximum average number of elements per bucket Sets the maximum load factor to ml.">max_load_factor()</a>), then the new number of buckets is at least <a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6" title="returns the number of buckets">size()</a> / <a class="el" href="classMyUnorderedMap.html#ab7ec15b70edeaee7de82916aa4c807e5" title="manages maximum average number of elements per bucket Sets the maximum load factor to ml.">max_load_factor()</a>.  <a href="classMyUnorderedMap.html#a4c5642e4af506856109ed7c60b9c8983">More...</a><br /></td></tr>
<tr class="separator:a4c5642e4af506856109ed7c60b9c8983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf8e5a542189c12e698b2902fb0e26"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a1fcf8e5a542189c12e698b2902fb0e26">insert</a> (const item &amp;pair)</td></tr>
<tr class="memdesc:a1fcf8e5a542189c12e698b2902fb0e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <a href="classMyUnorderedMap.html#a1fcf8e5a542189c12e698b2902fb0e26">More...</a><br /></td></tr>
<tr class="separator:a1fcf8e5a542189c12e698b2902fb0e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e4434ee351afaa8af32123e9358d18"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a16e4434ee351afaa8af32123e9358d18">insert</a> (item &amp;&amp;pair)</td></tr>
<tr class="memdesc:a16e4434ee351afaa8af32123e9358d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <a href="classMyUnorderedMap.html#a16e4434ee351afaa8af32123e9358d18">More...</a><br /></td></tr>
<tr class="separator:a16e4434ee351afaa8af32123e9358d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beb6c9c30325476330ce69ec4f87363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a8beb6c9c30325476330ce69ec4f87363">insert</a> (std::initializer_list&lt; item &gt; list)</td></tr>
<tr class="memdesc:a8beb6c9c30325476330ce69ec4f87363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <a href="classMyUnorderedMap.html#a8beb6c9c30325476330ce69ec4f87363">More...</a><br /></td></tr>
<tr class="separator:a8beb6c9c30325476330ce69ec4f87363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7470633b5f4493186d760ac68fda8c77"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7470633b5f4493186d760ac68fda8c77"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a7470633b5f4493186d760ac68fda8c77">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7470633b5f4493186d760ac68fda8c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.  <a href="classMyUnorderedMap.html#a7470633b5f4493186d760ac68fda8c77">More...</a><br /></td></tr>
<tr class="separator:a7470633b5f4493186d760ac68fda8c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964de5c042e7f26719e46303ba9486ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a964de5c042e7f26719e46303ba9486ad">operator=</a> (std::initializer_list&lt; item &gt; list)</td></tr>
<tr class="memdesc:a964de5c042e7f26719e46303ba9486ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.  <a href="classMyUnorderedMap.html#a964de5c042e7f26719e46303ba9486ad">More...</a><br /></td></tr>
<tr class="separator:a964de5c042e7f26719e46303ba9486ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0977f02c900484c2e334a70bee309f33"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a0977f02c900484c2e334a70bee309f33">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a0977f02c900484c2e334a70bee309f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist.  <a href="classMyUnorderedMap.html#a0977f02c900484c2e334a70bee309f33">More...</a><br /></td></tr>
<tr class="separator:a0977f02c900484c2e334a70bee309f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461391dda3732848f363cf89180dcfd0"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a461391dda3732848f363cf89180dcfd0">operator[]</a> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:a461391dda3732848f363cf89180dcfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist.  <a href="classMyUnorderedMap.html#a461391dda3732848f363cf89180dcfd0">More...</a><br /></td></tr>
<tr class="separator:a461391dda3732848f363cf89180dcfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd04efd1c89a37f9506c35b759f18a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#adbd04efd1c89a37f9506c35b759f18a5">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:adbd04efd1c89a37f9506c35b759f18a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classMyUnorderedMap.html#adbd04efd1c89a37f9506c35b759f18a5">More...</a><br /></td></tr>
<tr class="separator:adbd04efd1c89a37f9506c35b759f18a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02756f5f83c9c757ea14fda50014912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#ab02756f5f83c9c757ea14fda50014912">find</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:ab02756f5f83c9c757ea14fda50014912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classMyUnorderedMap.html#ab02756f5f83c9c757ea14fda50014912">More...</a><br /></td></tr>
<tr class="separator:ab02756f5f83c9c757ea14fda50014912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543e419f71c255daf1eab9308cd552b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a1543e419f71c255daf1eab9308cd552b">find</a> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:a1543e419f71c255daf1eab9308cd552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="classMyUnorderedMap.html#a1543e419f71c255daf1eab9308cd552b">More...</a><br /></td></tr>
<tr class="separator:a1543e419f71c255daf1eab9308cd552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a31b400cb2444e12a5f165c2df66989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a0a31b400cb2444e12a5f165c2df66989">erase</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a0a31b400cb2444e12a5f165c2df66989"><td class="mdescLeft">&#160;</td><td class="mdescRight">References and iterators to the erased elements are invalidated.  <a href="classMyUnorderedMap.html#a0a31b400cb2444e12a5f165c2df66989">More...</a><br /></td></tr>
<tr class="separator:a0a31b400cb2444e12a5f165c2df66989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e52a55259576289e5f76de9c352552"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#a72e52a55259576289e5f76de9c352552">erase</a> (Key &amp;&amp;key)</td></tr>
<tr class="memdesc:a72e52a55259576289e5f76de9c352552"><td class="mdescLeft">&#160;</td><td class="mdescRight">References and iterators to the erased elements are invalidated.  <a href="classMyUnorderedMap.html#a72e52a55259576289e5f76de9c352552">More...</a><br /></td></tr>
<tr class="separator:a72e52a55259576289e5f76de9c352552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae572b62e7bfe2f10e9606d04a0664ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#ae572b62e7bfe2f10e9606d04a0664ba8">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae572b62e7bfe2f10e9606d04a0664ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6" title="returns the number of buckets">size()</a> returns zero.  <a href="classMyUnorderedMap.html#ae572b62e7bfe2f10e9606d04a0664ba8">More...</a><br /></td></tr>
<tr class="separator:ae572b62e7bfe2f10e9606d04a0664ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b51f5d04e39ae2ffa02334e4db831"><td class="memItemLeft" align="right" valign="top"><a id="ad07b51f5d04e39ae2ffa02334e4db831"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyUnorderedMap.html#ad07b51f5d04e39ae2ffa02334e4db831">~MyUnorderedMap</a> ()</td></tr>
<tr class="memdesc:ad07b51f5d04e39ae2ffa02334e4db831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. <br /></td></tr>
<tr class="separator:ad07b51f5d04e39ae2ffa02334e4db831"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T, typename Hash = std::hash&lt;Key&gt;, typename Cmp = std::equal_to&lt;Key&gt;, typename Allocator = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt;<br />
class MyUnorderedMap&lt; Key, T, Hash, Cmp, Allocator &gt;</h3>

<p>MyUnordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity. Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. Keys with the same hash code appear in the same bucket. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into. </p>
<p>! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa805ead18c7abac53e5ede823d104411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa805ead18c7abac53e5ede823d104411">&#9670;&nbsp;</a></span>MyUnorderedMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::<a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor.constructs the unordered_map </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a> </dd></dl>

</div>
</div>
<a id="afdfad28fffbcb9b202ba6d5aa04fc4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfad28fffbcb9b202ba6d5aa04fc4af">&#9670;&nbsp;</a></span>MyUnorderedMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::<a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a> map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a>&amp; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac59ecf84abb917233edc582a05a199b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59ecf84abb917233edc582a05a199b7">&#9670;&nbsp;</a></span>MyUnorderedMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::<a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor. Constructs the container with the contents of other using move semantics. If alloc is not provided, allocator is obtained by move-construction from the allocator belonging to other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyUnorderedMap&amp;&amp;</td><td>map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae572b62e7bfe2f10e9606d04a0664ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae572b62e7bfe2f10e9606d04a0664ba8">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6" title="returns the number of buckets">size()</a> returns zero. </p>
<p>Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators. </p>

</div>
</div>
<a id="a632aa855c40b4c4c2ebaaffdae177b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632aa855c40b4c4c2ebaaffdae177b4f">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor. Constructs the container with the copy of the contents of other, copies the load factor, the predicate, and the hash function as well. If alloc is not provided, allocator is obtained by calling </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a> map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a>&amp; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7470633b5f4493186d760ac68fda8c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7470633b5f4493186d760ac68fda8c77">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>, bool&gt; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Args&amp;&amp;...</td><td>args </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator, bool&gt; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae737a9f673fee1db8f08726be2c0aef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae737a9f673fee1db8f08726be2c0aef2">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether the container is empty </p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a0a31b400cb2444e12a5f165c2df66989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a31b400cb2444e12a5f165c2df66989">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References and iterators to the erased elements are invalidated. </p>
<p>Invalidates iterators referring to contained elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>Key&amp; key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a72e52a55259576289e5f76de9c352552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e52a55259576289e5f76de9c352552">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References and iterators to the erased elements are invalidated. </p>
<p>Invalidates iterators referring to contained elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key&amp;&amp;</td><td>key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="adbd04efd1c89a37f9506c35b759f18a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd04efd1c89a37f9506c35b759f18a5">&#9670;&nbsp;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a> <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>Key&amp; key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="ab02756f5f83c9c757ea14fda50014912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02756f5f83c9c757ea14fda50014912">&#9670;&nbsp;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">const_iterator</a> <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>Key&amp; key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_iterator </dd></dl>

</div>
</div>
<a id="a1543e419f71c255daf1eab9308cd552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1543e419f71c255daf1eab9308cd552b">&#9670;&nbsp;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a> <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key&amp;&amp;</td><td>key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="a1fcf8e5a542189c12e698b2902fb0e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcf8e5a542189c12e698b2902fb0e26">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>, bool&gt; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const item &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>item&amp; pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a>&amp; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16e4434ee351afaa8af32123e9358d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e4434ee351afaa8af32123e9358d18">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classMyUnorderedMap_1_1Any__iterator.html">iterator</a>, bool&gt; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">item &amp;&amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item&amp;&amp;</td><td>pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;iterator, bool&gt; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8beb6c9c30325476330ce69ec4f87363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8beb6c9c30325476330ce69ec4f87363">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; item &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::initializer_list&lt;item&gt;</td><td>list </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa8d2988d453147bd081d51a947dc45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8d2988d453147bd081d51a947dc45f">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns average number of elements per bucket </p>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7ec15b70edeaee7de82916aa4c807e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ec15b70edeaee7de82916aa4c807e5">&#9670;&nbsp;</a></span>max_load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>manages maximum average number of elements per bucket Sets the maximum load factor to ml. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2440352d113f9723a12de9623ea0f62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2440352d113f9723a12de9623ea0f62f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap.html">mumap</a>&amp; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. Replaces the contents with a copy of the contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a>&amp; map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcd839d74e8244732cc55673208923fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd839d74e8244732cc55673208923fd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMyUnorderedMap.html">mumap</a>&amp; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMyUnorderedMap.html">mumap</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MyUnorderedMap&amp;&amp;</td><td>map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMyUnorderedMap.html" title="MyUnordered map is an associative container that contains key-value pairs with unique keys....">MyUnorderedMap</a>&amp; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a964de5c042e7f26719e46303ba9486ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964de5c042e7f26719e46303ba9486ad">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; item &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::initializer_list&lt;item&gt;</td><td>list </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0977f02c900484c2e334a70bee309f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0977f02c900484c2e334a70bee309f33">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>Key&amp; key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a461391dda3732848f363cf89180dcfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461391dda3732848f363cf89180dcfd0">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the value that is mapped to a key equivalent to key, performing an insertion if such key does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key&amp;&amp;</td><td>key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c5642e4af506856109ed7c60b9c8983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5642e4af506856109ed7c60b9c8983">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Hash  = std::hash&lt;Key&gt;, typename Cmp  = std::equal_to&lt;Key&gt;, typename Allocator  = std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMyUnorderedMap.html">MyUnorderedMap</a>&lt; Key, T, Hash, Cmp, Allocator &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of buckets to count and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (count &lt; <a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6" title="returns the number of buckets">size()</a> / <a class="el" href="classMyUnorderedMap.html#ab7ec15b70edeaee7de82916aa4c807e5" title="manages maximum average number of elements per bucket Sets the maximum load factor to ml.">max_load_factor()</a>), then the new number of buckets is at least <a class="el" href="classMyUnorderedMap.html#a118dacf40cf01226669ac54e8e2f98a6" title="returns the number of buckets">size()</a> / <a class="el" href="classMyUnorderedMap.html#ab7ec15b70edeaee7de82916aa4c807e5" title="manages maximum average number of elements per bucket Sets the maximum load factor to ml.">max_load_factor()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_t</td><td>new_size </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc();</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="my__unordered__map_8hpp_source.html">my_unordered_map.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
